---
layout : post
title : "O architektuře, část druhá: OOP nebo trop"
---

Jedním ze základních přístupů moderního programování, který se učí ve školách a využívá téměr ve všech oblastech, je objektově orientované programování (OOP). OOP je způsob jak organizovat kód a jak přemýšlet o problémech, resp. o tom, jak vyjádřit reálný problém v pojmech datových struktur a funkcí. Poskytuje výhody v podobě přehlednosti a rozšířitelnosti, ale stejně jako každá jiná abstrakce má i OOP svoji cenu. V [předchozím článku]({{ site.baseurl }}{% post_url 2015-11-22-architektura-1 %}) jsme zjistili, na čem závisí rychlost provádění počítačového programu; pojďme prozkoumat, jak tato zjištění ovlivní náš přístup k OOP.

<!--more-->

Takže předně si musíme vysvětlit, v čem OOP spočívá. Jak už vypovídá název, základním stavebním kamenem OOP jsou objekty. Objektem se rozumí datová struktura plus funkce (algoritmy), které s ní pracují -- buď ji modifikují, nebo o ní dávají nějaké informace (např. délku seznamu). Všechny takové funkce berou objekt, se kterým pracují jako jeden z parametrů. Většina OOP jazyků pro to zavádí zvláštní syntax, kde místo ```f(objekt, argumenty)``` píšeme ```objekt.f(argumenty)``` -- takto předávaný ```objekt``` je pak uvnitř funkce k dispozici pod jménem ```this``` nebo (méně často) ```self```. Funkcím, které s objektem takto pracují, pak říkáme _metody_ daného objektu.

Tato abstrakce je základem OOP. Umožňuje totiž přemýšlet o struktuře programu jako o samostatných oddělených objektech, které se starají každý sám o sebe, a navzájem spolu komunikují pevně definovaným způsobem, tj. voláním metod. Pokud je objektová hierarchie vytvořená rozumně, má každý objekt jen omezenou oblast působnosti, a tím se zmenší riziko, že by volání jedné funkce mělo nějaké vedlejší efekty na zdánlivě nesouvisejících místech. K tomu pomáhá i princip tzv. zapouzdření: vnější kód pracuje pouze s metodami objektu (s jeho _rozhraním_), a nepřistupují přímo na jeho data. To znamená, že každý objekt má plnou kontrolu nad tím, jak se jeho data mění za běhu programu. Také z toho vyplývá, že programátor může kdykoliv změnit vnitřní uspořádání dat objektu, aniž by bylo potřeba upravit kód, který s objektem pracuje, což vede ke zjednodušení údržby a případného dalšího rozšíření programu.

Co ale opravdu dodává OOP flexibilitu je možnost objekty od sebe odvozovat. Pokud je jeden objekt odvozen od druhého, obsahuje kromě svých vlastních dat a metod i všechny data a metody druhého objektu. Například v evidenčním systému firmy může být objekt ```Osoba```, který obsahuje základní osobní údaje, a pak od něj odvozené objekty jako ```Zákazník```, ```Zaměstnanec``` atd., které kromě osobních údajů ještě obsahují vlastní specifická data, např. seznam objednávek zákazníka, nebo plat zaměstnance. ```Zákazník``` i ```Zaměstnanec``` ale obsahují všechny metody ```Osoby```, a proto ta část kódu, která pracuje s ```Osobami``` (používá jejich rozhraní), může beze změny stejným způsobem pracovat i se ```Zaměstnanci```, ```Zákazníky``` i jakýmikoliv jinými objekty, které jsou od ```Osoby``` odvozené. Tomuto jevu se říká _polymorfismus_ -- k ```Zákazníkovi``` lze přistupovat jako k obecné ```Osobě```.

Poslední třešínkou na dortu je mechanismus tzv. _virtuálních metod_. Jestliže objekt prohlásí některou svoji metodu za virtuální, pak jakýkoliv objekt, který je od něj odvozený, může této metodě dodat vlastní implementaci. Mějme například objekt ```Kontejner``` z minulého článku, který má virtuální metodu ```přidat_prvek```. Potom mějme odvozené objekty ```Pole``` a ```Spojový_Seznam```. Protože přidání prvku do těchto typů kontejnerů vyžaduje odlišné kroky, každý z nich si metodu ```přidat_prvek``` implementuje jinak. Kód pracující s obecnými ```Kontejnery```, kterému jako kontejner předáme objekt typu ```Pole```, pak zavolání metody ```přidat_prvek``` přesměruje na konkrétní implementaci definovanou ```Polem```.

Takže když dáme dohromady vše, co jsme se o OOP dozvěděli, tak se nám rýsuje model, kterého bychom se mohli držet při programování herního enginu. Tak například všechny objekty, které reprezentují zbraně, mohou být odvozené od objektu ```Zbraň```, který je na oplátku společně se všemi objekty, které může nějaká postava mít v inventáři, odvozený z ```Předmětu```, což je zase ```Entita``` protože se aktivně podílí na herní logice. Každá úroveň hierarchie definuje nějaké virtuální metody, které jsou implementovány (specializovány) nižšími úrovněmi. A konečně všechny ```Entity``` jsou obsažené v kontejneru (konkrétně v poli, protože jsme poučeni z [předchozího článku]({{ site.baseurl }}{% post_url 2015-11-22-architektura-1 %})), a při každém tiku hry celý kontejner projdeme a na každé entitě zavoláme nějakou virtuální metodu, která pro danou entitu provede jeden krok simulace. Nu a hotovo, ne?

Bohužel každá abstrakce má svoji cenu. Tak předně vytvořit pole ```Entit``` není jen tak, protože každá ```Entita``` může ve skutečnosti být jeden z mnoha odvozených objektů, a ty nemusejí mít stejnou velikost. Nejjednodušší způsob (který je implicitně použitý v jazycích jako C# nebo Java, a i v C++ je to "standardní" přístup) je každý objekt umístit do paměti samostatně, a v poli držet jen ukazatele. Jak ale už víme, samostatné alokace jsou ke cache dost nepřátelské. Existují způsoby, jak se této nevýhodě vyhnout, ale nejsou triviální a taky mají svá omezení.

Další problém je skrytý v tom, že drtivé množství objektů, které nakonec bude engine opravdu vytvářet a používat, se nachází úplně vespod hierarchie. Ať chceme či nechceme, každý ```Plamenomet``` je zároveň ```Zbraň```, a tedy i ```Předmět``` a ```Entita```, a pokud každý z těchto objektů obsahuje nějaká data, musí je obsahovat i ```Plamenomet```. Když provádíme nějakou logiku, která je specifická pro ```Plamenomety```, tak pravděpodobně pracujeme hlavně s daty, které patří ```Plamenometu``` a ostatní nás nezajímají, ale přesto je do cache musíme načíst všechny. Takže i kdyby nastal případ, že pracujeme jen s ```Plamenomety```, a tedy bychom je mohli umístit natěsno za sebe do jednoho pole a vyhnout se tak nevýhodám zmíněným v předchozím odstavci, pořád nevyužíváme cache tak jak bychom mohli.

Ale dobře, dejme tomu, že jsme pečlivě navrhli objektovou hierarchii tak, abychom se vyhnuli i těmto problémům. I pak jsou tu problémy spojené s virtuálními metodami, kterých se zbavit nejde. Ten první je, že objekt s virtuálními metodami v sobě musí obsahovat nějaký malý blok dat, který umožňuje přesměrovat volání virtuální metody na správnou implementaci. To nám opět zabraňuje dosáhnout takové hustoty dat, jakou bychom si přáli. Ten druhý je samotný princip virtuální metody; fakt, že není potřeba vědět předem, jaký kód se spustí zavoláním virtuální metody je celý smysl a hlavní přednost tohoto mechanismu. Na druhou stranu to, že to _nelze_ předem vědět znamená, že překladač nemůže provést optimalizace, které se na tuto znalost spoléhají. Navíc kód (tj. jednotlivé instrukce) je taky potřeba načítat z paměti, a tedy má taky svoji cache. Pokud nelze rozumně předvídat, který kód je potřeba načíst (například proto, že je tatáž virtuální metoda volána na objektech různých odvozených tříd), pak jej nelze rozumně mít připravený předem v cache, a opět dochází k prodlevám, kdy procesor čeká na načtení instrukcí z hlavní paměti.

Takže OOP vede k nižší hustotě dat a horšímu využití cache. Znamená to, že nám je k ničemu? To rozhodně ne, protože výhody, které poskytuje, pro nás pořád mají hodnotu, jen je potřeba mít na paměti i to, jakou za ně zaplatíme cenu. Velká část kódu se nachází mimo kritickou cestu, kde zdržení (v rozumné míře) nepředstavuje až takový problém, a tam určitě OOP uplatnit lze. Ale pro kód, který je volán opakovaně (jako např. herní logika), a pro data, ke kterým je přistupováno neustále (jako např. seznam všech herních objektů), může být cena OOP příliš vysoká. Pokud na takových místech chceme dosáhnout vysoké hustoty dat a využití cache a přitom si zachovat flexibilitu a schopnost kód rozšířit, musíme zaujmout trochu jiný přístup, který si nastíníme v příštím článku.